package processing.test.symbology;

/* autogenerated by Processing revision 1286 on 2022-12-03 */
import android.app.ProgressDialog;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.RatingBar;
import android.widget.RatingBar.OnRatingBarChangeListener;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;

import com.google.android.gms.auth.api.signin.GoogleSignIn;
import com.google.android.gms.auth.api.signin.GoogleSignInAccount;
import com.google.android.gms.auth.api.signin.GoogleSignInClient;
import com.google.android.gms.auth.api.signin.GoogleSignInOptions;
import com.google.android.gms.common.api.ApiException;
import com.google.android.gms.common.api.Result;
import com.google.android.gms.drive.Drive;
import com.google.android.gms.games.AnnotatedData;
import com.google.android.gms.games.Games;
import com.google.android.gms.games.GamesClientStatusCodes;
import com.google.android.gms.games.SnapshotsClient;
import com.google.android.gms.games.snapshot.Snapshot;
import com.google.android.gms.games.snapshot.SnapshotMetadata;
import com.google.android.gms.games.snapshot.SnapshotMetadataBuffer;
import com.google.android.gms.games.snapshot.SnapshotMetadataChange;
import com.google.android.gms.tasks.Continuation;
import com.google.android.gms.tasks.OnCompleteListener;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.Task;

import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.concurrent.*;
import java.util.Random;
import java.lang.Math;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Hashtable;
import java.util.concurrent.*;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Symbology extends PApplet {

boolean debug = false;
int screen = 1;
BattleScreen battleScreen;
Player player;
ShopScreen shopScreen;
SplashScreen splashscreen;
Theme currentTheme;
PowerUp[] powerUps = new PowerUp[4];
int fadeMax = 60;
int fade = 0;
boolean fading = true;
int screenAfter = 1;

 public void setup(){
    //fullScreen(); // use when compiled for android
    /* size commented out by preprocessor */; // use when testing on Processing IDE

    // enitializing several drawing properties
    frameRate(30);
    ellipseMode(CENTER);
    rectMode(CORNER);
    textSize(min(width, 3*height/4)/18);
    fill(0);
    stroke(0);
    textAlign(CENTER);
    strokeWeight(0);

    // initializing system variables
    player = new Player(500, 1, 0); // 3000 base hp, level 1, 1000 currency
    powerUps = new PowerUp[]{
        new PowerUp("Grow Board",0,"grow",1), // start with 5 grow powerUps
        new PowerUp("Shrink Board",0,"shrink",-1), // start with 5 shrink powerUps
        new PowerUp("Skip Level",0,"skip",'l'), // start with 5 skip powerUps
        new PowerUp("Heal Player",0,"heal",'h') // start with 5 heal powerUps
    };
    currentTheme = new AnimatedTheme(color(255, 150, 150), color(50, 20, 20), color(60, 20, 20), "0", .6f, width, height);
    battleScreen = new BattleScreen(width, height, player, powerUps);
    shopScreen = new ShopScreen(width, height, player,currentTheme);
    splashscreen = new SplashScreen(width,height);
    for(int i = 0; i < powerUps.length; i++){
        powerUps[i].resize(width/5, width/5);
        if(i>1)powerUps[i].loadScreen(battleScreen);
    }
}

 public void mousePressed(){
    switch(screen){
        case 3:
            battleScreen.mousePressed(mouseX, mouseY);
            break;
    }

}

 public void mouseReleased(){
    switch(screen){
        case 3:
            battleScreen.mouseReleased(mouseX, mouseY);
            break;
    }
}

 public void keyPressed(){
    if(key=='d'){
        debug=!debug;
    }
    if(key=='+'){
        battleScreen.gameBoard.resize(battleScreen.gameBoard.getSize()+1);
    }
    if(key=='-'){
        battleScreen.gameBoard.resize(battleScreen.gameBoard.getSize()-1);
    }
}

 public void draw(){
    switch (screen){
        case 1:
            if(splashscreen.show()&&!fading){
                fade(30,2);
                loadFromSaveString(splashscreen.loadedString);
              }
            fade();
            break;
        case 2:
            if(shopScreen.show(powerUps)==1)
                fade(30,3);
            fade();
            break;
        case 3:
            if(!fading && !battleScreen.update(currentTheme)){
                player.spellbook.toggleable = false;
                player.level = player.level - (player.level - 1)%4;
                println(getSaveString());
                fade(30, 2);
            }
            battleScreen.show(currentTheme, debug);
            fade();
            break;
    }
}

 public void loadFromSaveString(String save){
    if(save.length()==0)save = "500;1;0;1.0;1.0;23,wb#0;0;0;0";
    String greaterParts[] = save.split("#");
    player = new Player(greaterParts[0]);
    String powerUpParts[] = greaterParts[1].split(";");
    for(int i = 0; i < 4; i++){
        powerUps[i].count = parseInt(powerUpParts[i]);
    }
}
 public String getSaveString(){
    String out = player.toString() + "#";
    for(int i = 0; i < 3; i++)
        out += powerUps[i].count + ";";
    out += powerUps[3].count + "";
    return out;
}

 public int typeToTint(char type){ // get the color tint based on a type char code
    switch(type){
        case 'a':
            return color(255,255,150);
        case 'e':
            return color(50,150,50);
        case 'f':
            return color(255,100,100);
        case 'w':
            return color(150,150,255);
    }
    return color(200);
}

 public void addParticle(Particle p){
    battleScreen.addParticleP(p);
}

 public void fade(int frames, int screenAfter_){
    if(!fading){
        fading = true;
        fadeMax = frames;
        fade = -frames;
        screenAfter = screenAfter_;
    }
    fade();
}
 public void fade(){
    if(fading){
        fill(0,0,0,255-(255*abs(fade++))/(fadeMax+1));
        stroke(0,0,0,255-(255*abs(fade++))/(fadeMax+1));
        rect(-3,-3,width+3,height+3);
        if(fade==0)
            screen = screenAfter;
        if(fade>=fadeMax){
            fading = false;
            fade = 0;
            fadeMax = 0;
        }
    }
}
class AnimatedTheme extends Theme {
    float speed;
    float hue;

    public AnimatedTheme(int on_, int off_, int background_, String backgroundImageFilename, float speed_, int wid, int hei){
        super(on_, off_, background_, backgroundImageFilename, wid, hei);
        speed=speed_;
        hue = hue(on);
    }

    @Override
    public void update(){ // changes the hue over time
        hue = (hue+speed);
        if(hue>256)hue-=256;
    }
    @Override
    public int getOn(){
        colorMode(HSB,255);
        on = color(floor(hue), saturation(on), brightness(on)); // recolor based on hue
        colorMode(RGB,255);
        return on;
    }
    @Override
    public int getOff(){
        colorMode(HSB,255);
        off = color(floor(hue), saturation(off), brightness(off)); // recolor based on hue
        colorMode(RGB,255);
        return off;
    }
    @Override
    public int getBackground(){
        colorMode(HSB,255);
        background = color(floor(hue), saturation(background), brightness(background)); // recolor based on hue
        colorMode(RGB,255);
        return background;
    }
}

class BattleScreen extends Screen{
    Player player; // Stores player stats and Spell book
    Enemy enemy;
    GameBoard gameBoard; // Wraps a State with rendering data and methods
    PowerUp powerUps[];
    int lastX, lastY; // The x, y position of the mouse when the mouse was last clicked
    ArrayList<Particle> particles = new ArrayList<Particle>(100);

    public BattleScreen(int width_, int height_, Player player_, PowerUp powerUps_[]){
        super(width_, height_);
        player = player_;
        enemy = new Enemy(player.getLevel());
        gameBoard = new GameBoard((int)gameWidth);
        powerUps = powerUps_;
    }

    public void mousePressed(int mx, int my){
        // store the position of the mouse / finger when the mouse was pressed down
        lastX = mx;
        lastY = my;
        // allow spellbook to move
        player.spellbook.toggleable = true;
    }

    public void mouseReleased(int mx, int my){
        player.spellbook.toggleable = false;
        float displacement = map(lastX-mouseX, 0, 2*margin, 0, 1); // check how much the user has swiped
        if(displacement > 0.5f)player.spellbook.visible = true; // lock the spellbook in place if it is sufficiently on screen
        if(displacement <-0.5f)player.spellbook.visible = false; // stow the spellbook if it is swiped off sufficiently

        // if you click the gameBoard while the spellbook is not open:
        if(!player.spellbook.visible && pow(lastX-mx, 2)+pow(lastY-my, 2)<pow(margin/2, 2)){
            gameBoard.click(mx, my); // tell the board
            Spell currentBoardSpell = player.spellbook.getSpell(gameBoard.getEncoded()); // get the spell from spellbook if there is one
            if(currentBoardSpell!=null && currentBoardSpell.available){ // if there is a spell
                int damageTaken = enemy.takeDamage(currentBoardSpell.damage, currentBoardSpell.type);
                gameBoard.scramble();
                for(int i = currentBoardSpell.damage; i > 0; i >>= 1){
                    addParticle(new Particle(gameBoard.center.x, gameBoard.center.y, random(-width/40, width/40), random(-width/40, width/40), 20, log(currentBoardSpell.damage*5)*width/90, typeToTint(currentBoardSpell.type)));
                }
                for(int i = damageTaken; i > 0; i >>= 1){
                    addParticle(new Particle(enemy.center.x, enemy.center.y, random(-width/40, width/40), random(-width/40, width/40), 20, log(damageTaken*5)*width/90, typeToTint(currentBoardSpell.type)));
                }
                if(!enemy.alive()){ // if you kill the enemy, make a new one
                    player.level++;
                    int currencyEarned = floor(enemy.maxHp * random(8, 12));
                    for(int i = currencyEarned; i > 0; i >>= 1){
                        addParticle(new Particle(enemy.center.x, enemy.center.y, random(-width/40, width/40), random(-width/40, width/40), 500000, width/2, height*1.5f, log(currencyEarned*5)*width/200, randomGoldColor(), 0, height/2));
                    }
                    player.earnCurrency(currencyEarned);
                    enemy = new Enemy(player.level);
                }
            }
        }
        
        // if you click a powerUp without the spellbook open
        if(!player.spellbook.visible && mx==constrain(mx, wid/10, 9*wid/10) && my==constrain(my, (hei/2+gameWidth/2+hei-margin-wid/5)/2, (hei/2+gameWidth/2+hei-margin+wid/5)/2)){
            int x = floor((mx-wid/10)/(wid/5)); // which one
            if(x == constrain(x, 0, 3)) // anti-nullPointerException measures
                powerUps[x].use(gameBoard);
        }
        else player.spellbook.click(mx, my, this);
    }

    public boolean update(Theme theme){
        theme.update();
        LinkedBlockingQueue<Particle> removalQ = new LinkedBlockingQueue<Particle>();
        for(Particle p : particles){
            p.update();
            if(p.inactive())
                removalQ.offer(p);
        }
        while(!removalQ.isEmpty()){
            particles.remove(removalQ.poll());
        }
        if(!player.spellbook.visible)player.takeDamage(enemy.getDamage());
        return player.alive();
    }

    public void show(Theme theme, boolean debug){
        background(theme.getBackground());
        image(theme.getBackgroundImage(), 0, 0);
        enemy.showHp(0, 0, wid, wid/64*9, theme);
        enemy.show(wid/2-margin, (hei/2-gameWidth/2-margin)/2, margin*2, margin*2);
        gameBoard.show(wid/2-gameWidth/2, hei/2-gameWidth/2, gameWidth, theme.getOn(), theme.getOff(), debug);
        for(int i=0; i<4; i++){
            powerUps[i].show(wid/10 * (1+2*i), (hei/2+gameWidth/2+hei-margin-wid/5)/2, wid/5, wid/5);
        }
        for(Particle p : particles){
            p.show();
        }
        player.showHp(0, hei-width/64*9, wid, wid/64*9, theme);
        player.spellbook.show(map(lastX-mouseX, 0, 2*margin, 0, 1), wid-1.5f*margin, hei-3*margin, this, theme);
    }

    public void addParticleP(Particle p){
        particles.add(p);
    }

    private int randomGoldColor(){
        float randomVal = random(0,100);
        int red = floor(map(randomVal, 0, 100, 184, 250));
        int gre = floor(map(randomVal, 0, 100, 132, 243));
        int blu = floor(map(randomVal, 0, 100, 68, 149));
        return color(red, gre, blu);
    }
}
class Enemy{
    private char[] TYPES = {'n','a','e','f','w'};
    private int maxHp;
    private int hp;
    private int damage;
    private char type;
    private PImage sprite;
    private boolean boss = false;
    public PVector center = null;

    Enemy(int maxHp_, int damage_, char type_, PImage sprite_){
        maxHp = maxHp_;
        hp = maxHp_;
        damage = damage_;
        type = type_;
        sprite = sprite_;
    }
    Enemy(int seed){
        boss = seed%4==0;
        randomSeed(seed); // set the random seed so each level is always the same, and different levels are different and we don't have to make them
        maxHp = floor(4*pow(1.01f, seed)*random(.8f,1.2f)*map((seed%4), 0, 3, 1, 3)*(boss?2:1));
        hp = maxHp;
        damage = max(floor(pow(1.01f, seed)*random(.8f,1.2f)*(boss?2:1)),1);
        type = randomResistance(seed);
        sprite = loadImage("assets/monsters/"+floor(random(0,4))+".monster.png");
        sprite.resize(width/2, width/2); // small optimization
    }

    public int takeDamage(int amount, char damageType){
        int damage = 0;
        switch(type){
            case 'n': // if the enemy is of type neutral it just takes the damage
                damage=amount;
                break;
            case 'a': // if the enemy is of type air it takes double damage from air spells and half from others
                damage=(damageType=='a')?amount*2:amount/2;
                break;
            case 'e': // if the enemy is of type earth it takes double damage from fire spells and half from others
                damage=(damageType=='f')?amount*2:amount/2;
                break;
            case 'f': // if the enemy is of type fire it takes double damage from water spells and half from others
                damage=(damageType=='w')?amount*2:amount/2;
                break;
            case 'w': // if the enemy is of type water it takes double damage from earth spells and half from others
                damage=(damageType=='e')?amount*2:amount/2;
                break;
        }
        hp-=damage;
        return damage;
    }

    public boolean alive(){
        return hp>0;
    }

    public int getHp(){
        return hp;
    }
    public int getMaxHp(){
        return maxHp;
    }
    public int getDamage(){
        return damage;
    }

    private char randomResistance(int seed){ // get a random resistance from the seed
        if(seed<=4)return 'n';
        return TYPES[floor(random(0,4))];
    }

    public void show(float x, float y, float w, float h){
        if(boss){
            x-=w/2;
            y-=h/2;
            w*=2;
            h*=2;
        }
        if(center==null)center=new PVector(x+w/2, y+h/2);
        tint(typeToTint(type));
        image(sprite, x, y, w, h);
        tint(255);
    }

    public void showHp(float x, float y, float w, float h, Theme t){
        float edge = map(hp,0,maxHp,9*w/64,w);
        edge = min(edge - edge%(w/15) + w/15, w);
        fill(t.getOff());
        rect(x+edge,y+h/20,w-edge,9*h/10);
        fill(t.getOn());
        rect(x, y+h/20, edge, 9*h/10);
        image(t.enemyHealthBar, x, y, w, h);
    }
}
class GameBoard{
    private int scaleFactor = 20;
    private State state;
    private int lastSize = 0;
    private PImage board, original, boarder; 
    private PVector topCorner = null;
    private PVector dimensions = null;
    public PVector center = null;

    // Constructor
    GameBoard(State state_, int gWidth){
        state = state_;
        loadImages("assets/brick.board.png", gWidth);
        boarder = loadImage("assets/boarder.board.png");
        boarder.resize((int)(gWidth*1.2f), (int)(gWidth*1.2f));
    }
    GameBoard(int gWidth){
        this(new State(3), gWidth);
    }

    // State Functions
    public void click(int mx, int my){
        int size = getState().getSize();
        int x = floor((mx-topCorner.x)/(dimensions.x/size));
        int y = floor((my-topCorner.y)/(dimensions.y/size));
        if(!(x>=size||x<0 || y>=size||y<0)){
            state.click(x,y);
        }
    }
    public void scramble(){
        state.scramble();
    }
    public int getSize(){
        return state.getSize();
    }
    public State getState(){
        return state;
    }
    public boolean resize(int newSize){
        return state.resize(newSize);
    }
    public boolean onBoard(int mx, int my){
        int x = floor((mx-topCorner.x));
        int y = floor((my-topCorner.y));
        return !(x>=dimensions.x||x<0 || y>=dimensions.y||y<0);
    }
    public long getEncoded(){
        return state.getEncoded();
    }

    // Load Images
    private void loadImages(String filename, int gWidth){
        original = loadImage(filename);
        board = original.get(((7-state.getSize())/2+(1-state.getSize()%2))*16*scaleFactor,((7-state.getSize())/2+(1-state.getSize()%2))*16*scaleFactor,16*state.getSize()*scaleFactor,16*state.getSize()*scaleFactor);
        board.resize(gWidth, gWidth);
    }

    // Show
    public void show(float x, float y, float gWidth, int on, int off, boolean debug){
        int size = state.getSize();
        if(topCorner==null)topCorner=new PVector(x, y);
        if(dimensions==null)dimensions=new PVector(gWidth, gWidth);
        if(center==null)center=new PVector(x+gWidth/2, y+gWidth/2);
        if(size<1)return;
            if(size!=lastSize){
                board = original.get(((7-state.getSize())/2+(1-state.getSize()%2))*16*scaleFactor, ((7-state.getSize())/2+(1-state.getSize()%2))*16*scaleFactor, 16*state.getSize()*scaleFactor, 16*state.getSize()*scaleFactor);
                lastSize = size;
                board.resize((int)gWidth, (int)gWidth);
            }
        tint(red(on), green(on), blue(on));
        image(boarder, x-gWidth*0.1f, y-gWidth*0.1f, gWidth*1.2f, gWidth*1.2f);
        tint(255,255,255);
        state.show(x, y, gWidth, on, off, debug);
        image(board, x, y, gWidth, gWidth);
    }
}
class Particle {
    PVector pos, vel, target, shape;
    int c;
    float forceMagnitude, shrinkRadius, vanishRadius;
    int age = 0, maxAge;
    /* 
    Notes:
    - monster dies spews out coins in all directions (possible a number related to log of actual coins or something capped) that go to coin bank
    - spell activates throw based on damage size and type color at monster
    - on hit, spalsh particles out of monster on hit with color based on spell type and number based on damage done (ie if they are resistant less particles)
    - magic particles are at least a little translucent
    */

    public Particle(float posx, float posy, float velx, float vely, float forceMagnitude_, float targetx, float targety, float shapex, float shapey, int c_, float shrinkRadius_, float vanishRadius_, int maxAge_){
        pos = new PVector(posx, posy);
        vel = new PVector(velx, vely);
        forceMagnitude = forceMagnitude_;
        target = new PVector(targetx, targety);
        shape = new PVector(shapex, shapey);
        c = c_;
        shrinkRadius = shrinkRadius_;
        vanishRadius = vanishRadius_;
        maxAge = maxAge_;
    }
    // age based vanishing
    public Particle(float posx, float posy, float velx, float vely, int maxAge_, float shapex, float shapey, int c_){
        this(posx, posy, velx, vely, 0, -10, -10, shapex, shapey, c_, 0, 0, maxAge_);
    }
    public Particle(float posx, float posy, float velx, float vely, int maxAge_, float size, int c_){
        this(posx, posy, velx, vely, 0, -10, -10, size, size, c_, 0, 0, maxAge_);
    }
    // target based vanishing
    public Particle(float posx, float posy, float forceMagnitude_, float targetx, float targety, float size, int c_, float shrinkRadius_, float vanishRadius_){
        this(posx, posy, 0, 0, forceMagnitude_, targetx, targety, size, size, c_, shrinkRadius_, vanishRadius_, -1);
    }
    public Particle(float posx, float posy, float velx, float vely, float forceMagnitude_, float targetx, float targety, float size, int c_, float shrinkRadius_, float vanishRadius_){
        this(posx, posy, velx, vely, forceMagnitude_, targetx, targety, size, size, c_, shrinkRadius_, vanishRadius_, -1);
    }

    public void update(){
        age++;
        float angle = atan2(target.y-pos.y, target.x-pos.x), m = forceMagnitude/(.001f + sqdist(pos, target));
        PVector acc = new PVector(cos(angle)*m, sin(angle)*m);
        acc.limit(width/150);
        vel.add(acc);
        vel.limit(width/15);
        pos.add(vel);

    }
    public void show(){
        fill(c);
        stroke(c);
        ellipse(pos.x, pos.y, shape.x, shape.y);
    }
    public boolean inactive(){
        if(maxAge != -1)return age > maxAge;
        return (vanishRadius*vanishRadius > sqdist(pos, target));
    }

    private float sqdist(PVector a, PVector b){
        float x = a.x - b.x;
        float y = a.y - b.y;
        float d = x*x+y*y;
        return (d==d)?d:1;
    }
    private float dist(PVector a, PVector b){
        return sqrt(sqdist(a, b));
    }
}
class Player{

    private int hp;
    private int maxHp;
    private float damageMultiplier = 1.0f;
    private float earningsMultiplier = 1.0f;
    private int level;
    public Spellbook spellbook;
    private int currency;
    private String stats[] = { "Max HP", "Spell Damage", "Armor", "Earnings" };

    public Player(int maxHp_, int level_, int currency_){
        maxHp = maxHp_;
        hp = maxHp_;
        level = level_;
        spellbook = new Spellbook("spells.dat", "0");
        currency = currency_;
    }

    public Player(String encoded){
        this(encoded.split(";"));
    }

    public Player(String[] parts){
        this(parseInt(parts[0]),parseInt(parts[1]),parseInt(parts[2]));
        spellbook.updateAvailableSpells(parts[5]);
        damageMultiplier = parseFloat(parts[3]);
        damageMultiplier = parseFloat(parts[4]);
        testGetUpgrade();
    }

    public void takeDamage(int damage){
        hp-=damage;
    }

    public void effect(char stat){
        switch(stat) {
            case 'h':
                hp = maxHp;
                break;
            case 'l':
                level++;
                break;
        }
    }

    public int getLevel(){
      return level;
    }

    public boolean alive(){
        return hp > 0;
    }

    public void revive(){
        hp = maxHp;
    }

     public void earnCurrency(float earnings){
        currency += ceil(earnings * earningsMultiplier);
    }

     public void setCurrency(int currency_){
        currency = currency_;
    }

     public int getCurrency(){
        return currency;
    }

    public void showHp(float x, float y, float w, float h, Theme t){
        float edge = map(hp,0,maxHp,7*w/64,w);
        edge = min(edge - edge%(w/(maxHp/50)) + w/(maxHp/50), w);
        fill(t.getOff());
        rect(x+edge,y+h/20,w-edge,9*h/10);
        fill(t.getOn());
        rect(x, y+h/20, edge, 9*h/10);
        image(t.playerHealthBar, x, y, w, h);
    }

    public String toString(){
        String out = "";
        out += maxHp + ";";
        out += level + ";";
        out += currency + ";";
        out += damageMultiplier + ";";
        out += earningsMultiplier + ";";
        out += spellbook.getAvailableSpells();
        return out;
    }

     public void testGetUpgrade(){
        int temp = level;
        while(level++<temp+25){
            getUpgrade();
        }
    }

    public String getUpgrade(){
        randomSeed(level);
        int stat = floor(random(128)%4);
        return stats[floor(random(128)%4)];
    }

    public void upgrade(){
        randomSeed(level);
        int stat = floor(random(128)%4);
        switch(stat){
            case 0:
            case 2:
                maxHp *= random(1.01f, 1.2f);
                break;
            case 1:
                damageMultiplier *= random(1.01f, 1.2f);
                break;
            case 3:
                earningsMultiplier *= random(1.01f, 1.2f);
                break;
        }
    }
}
class PowerUp{
    String name;
    int count;
    int resize;
    char stat;
    int magnitude;
    PImage favicon;
    BattleScreen screen;

    public PowerUp(String name_, int count_, String favicon_){
      name = name_;
      count = count_;
      favicon = loadImage("assets/powerUps/" + favicon_ + ".powerUp.png");
    }
    public PowerUp(String name_, int count_, String favicon_, int resize_){
        this(name_, count_, favicon_);
        resize = resize_;
    }
    public PowerUp(String name_, int count_, String favicon_, char stat_){
        this(name_, count_, favicon_);
        stat = stat_;
    }

    public void resize(int x, int y){
        favicon.resize(x, y);
    }

    public void loadScreen(BattleScreen screen_){
        screen = screen_;
    }

    public void show(float x, float y, int w, int h) {
        image(favicon, x, y);
        fill(255);
        ellipse(x+w*.8f, y+h*.85f, w/3, h/3);
        textAlign(CENTER, CENTER);
        String tempCount = "" + count;
        textSize(w/2/pow(tempCount.length()+1, .7f));
        fill(0);
        text(tempCount, x+w*.8f, y+h*.79f);
    }

    public boolean use(GameBoard gb){
        if(count > 0){
            if(resize!=0){
                if(!gb.resize(gb.getSize()+resize))return false;
                gb.scramble();
            }
            if(screen != null){
                screen.player.effect(stat);
                if(stat == 'l')
                    screen.enemy = new Enemy(screen.player.getLevel());
            }
            count--;
            return true;
        }
        return false;
    }
}
abstract class Screen {
    int wid;
    int hei;
    float margin;
    float gameWidth;
    
    public Screen(int width_, int height_){
        wid = width_;
        hei = height_;
        margin = min(wid, hei/2)/8;
        gameWidth = margin*6;
    }
}




class ShopScreen extends Screen{
    private static final float widthRatio  = 4.3605f;
    private static final float heightRatio = 9.6429f;
    private final float new_width   = width/3+(width/25f*2);
    private final float new_height  = height/3-(height/(135f/4));
    private final float buttonSize  = width*(496f/3000);

    PowerUp powerUps[];
    Theme theme;
    PImage shop;
    String buttonFilenames[] = { 
        "assets/powerUps/grow.powerUp.png", 
        "assets/powerUps/shrink.powerUp.png", 
        "assets/powerUps/skip.powerUp.png", 
        "assets/powerUps/heal.powerUp.png", 
        "assets/buttons/buy.png", 
        "assets/buttons/cancel.png", 
        "assets/buttons/chest.png", 
        "assets/buttons/go.png", 
        "assets/items/spell.item.png", 
        "assets/40f.png", 
        "assets/Shop.png",
        "assets/items/shopkeeper.png"
        };
    HashMap<String, PImage> buttons = new HashMap<String, PImage>(buttonFilenames.length*2);
    boolean clicked=false;//prevents overlaping screens
    int bools[]={1, 1, 1, 1, 1, 1, 1, 1,1};//prevents overlaping screens
    Spellbook spellbook;
    int randSpell[]={1, 2, 3, 4};
    boolean RandSpell=false;
    boolean bought[]={false, false, false, false, false};//prevents repeats spells
    String Bought="assets/buttons/chest.png";//will appear if you buy spell
    int spellcount=1;
    int cantAfford=0;
    int max=0;
    int Statprice=0;
   
    Player player;
    
    
    public void getStatPrice(){

       if(player.currency>max)
       max=player.currency;
       
       float random = random(1.2f)+.2f; 
       Statprice=PApplet.parseInt(max*random);
         
        
    }
    
   
    public ShopScreen(int width_, int height_, Player player_, Theme theme_){
        super(width_, height_);
        for(String imageFilename : buttonFilenames){
            addImage(imageFilename);
        }
        player=player_;
        spellbook = player_.spellbook; // Fixed a thing where you made your own spellbook instead of using the player's spellbook
        theme = theme_;
        
    }

    private void addImage(String name){
        buttons.put(name, loadImage(name));
    }
    
     public void makebutton(float width, float height, String image, float size){ // draw a button with a size
        image(buttons.get(image), width, height, size, size); // this is not especially fast because it resizes, but it is necessary because of the different sized images
    }
    
    
    public boolean priceCheck(int price){
      if(player.getCurrency()<price){
        for(int i=0;i<8;i++)
           bools[i]=1;
           clicked=false;
           cantAfford=1;
           return false;   
      }
      return true;
    }
    
    /*public void shoopKeeper(){
        if(clicked==false){
          makebutton(new_width+(width/widthRatio), new_height+(height/5), "assets/items/shopkeeper.png", buttonSize);
          if(cantAfford==1){
             textSize(width/25);
             text("why you no\n"+ "have money",new_width+(width/widthRatio)*1.4,new_height+(height/5)*1.53);  
          }
        }     
    }
*/
     public void RandomSpells(){//gets a random spell 
        int remaining=min(spellbook.someSpellsUnavailable(), 4);

        for(int i=0;i<4;i++){
            boolean set=false;  
            if(i>=remaining){
                set=true;
                randSpell[i]=-1; 
            } else while(set==false){
                int random = floor(random(spellbook.getSpellCount()-1)+1); 
                if(!spellbook.getSpellIndexed(random).available){
                    set=true;
                    randSpell[i]=random;   
                
                }        
            }
        }   

        RandSpell=true;
    }
    
    public void StatScreen(){     
   
      if( bought[4]==false){
       bought[4]=true;
       getStatPrice();   
      }
    
      fill(255, 165, 44); 
     
      rect(width/9.70f, height/4, width*.8f, height*0.47407407407f);
      
      makebutton(width/3, height/3, "assets/items/shopkeeper.png", buttonSize*2);//displayimage change whne image made
      makebutton(3*width/4, height/2+width/4, "assets/buttons/cancel.png", buttonSize);//cancel
      makebutton(width/10, height/2+width/4, "assets/buttons/buy.png", buttonSize);//buy
      fill(0);
      stroke(0);
      textSize(width/15);
      text(Statprice+" coins", width/2, height/1.5f); 
      text(player.getUpgrade(), width/2, height/1.8f); 
      
      
       if(mouseX >= width/2+width/4 && mouseX <= width/2+width/4 + buttonSize && mouseY >= height/2+width/4 && mouseY <= height/2+width/4 + buttonSize && mousePressed){   //cancle
             bools[8]=1;
             clicked=false;
       }
       if(mouseX >= width/2-width/2.5f && mouseX <= width/2-width/2.5f + buttonSize && mouseY >= height/2+width/4 && mouseY <=height/2+width/4 + buttonSize && mousePressed){ 
         print("hi"); 
         if(priceCheck(Statprice)){
           if(bools[8]==0){
            bought[4]=false;  
            bools[8]=1;//prevents mouse hold
            player.upgrade();
            clicked=false;
            
           }
            player.setCurrency(player.getCurrency()-Statprice);
            cantAfford=0;
          
           }  
        }  
    
 
    }
    
    public void buySpellScreen(int spell){
        fill(255, 165, 44);
        Spell temp = spellbook.getSpellIndexed(spell);
        int spellCost=(int)(Math.pow(1.1f, spellcount)*10)*(temp.damage);
        rect(width/9.70f, height/4, width*.8f, height*0.47407407407f);
     
        temp.show(width/2-(width/3.125f), height/2-(height/4.7f), (width/1.5f), (width/1.5f), theme);
        makebutton(3*width/4, height/2+width/4, "assets/buttons/cancel.png", buttonSize);//cancel
        makebutton(width/10, height/2+width/4, "assets/buttons/buy.png", buttonSize);//buy
    
        textSize(width/15);
        text(spellCost+" coins", width/2.7f, height/1.5f); 
        textAlign(CENTER);
        clicked=true;
        
        if(mouseX >= width/2+width/4 && mouseX <= width/2+width/4 + buttonSize && mouseY >= height/2+width/4 && mouseY <= height/2+width/4 + buttonSize && mousePressed){   //cancle
             for(int i=4;i<8;i++)
             bools[i]=1;
             clicked=false;
        }
        if(mouseX >= width/2-width/2.5f && mouseX <= width/2-width/2.5f + buttonSize && mouseY >= height/2+width/4 && mouseY <=height/2+width/4 + buttonSize && mousePressed){ 
          if(priceCheck(spellCost)){
            spellcount++;
            if(bools[4]==0){
            bought[0]=true;  
            bools[4]=1;//prevents mouse hold
            clicked=false;
            }
            if(bools[5]==0){
            bought[1]=true; 
            bools[5]=1;//prevents mouse hold
            clicked=false;
            }
            if(bools[6]==0){
            bought[2]=true;   
            bools[6]=1;//prevents mouse hold
            clicked=false;
            }
            if(bools[7]==0){
            bought[3]=true;  
            bools[7]=1;//prevents mouse hold
            clicked=false;
            }
            player.setCurrency(player.getCurrency()-spellCost);
            cantAfford=0;
           }
        }  
    }

     public void buyScreen(String name, PowerUp powerup[]){// you can buy or cancle items
        fill(255, 165, 44);
        int cost=20;
        rect(width/9.70f, height/4, width*.8f, height*0.47407407407f);
        makebutton(width/3, height/3, name, buttonSize*2);//displayimage
        makebutton(width/2+width/4, height/2+width/4, "assets/buttons/cancel.png", buttonSize);//cancle
        makebutton(width/2-width/2.5f, height/2+width/4, "assets/buttons/buy.png", buttonSize);//buy
        
        fill(0);
        stroke(0);
        textSize(width/15);
        text(cost+" coins", width/2, height/1.5f); 
 
        
        clicked=true;

         if(mouseX >= width/2+width/4 && mouseX <= width/2+width/4 + buttonSize && mouseY >= height/2+width/4 && mouseY <= height/2+width/4 + buttonSize && mousePressed){   //cancle
             for(int i=0;i<4;i++)
             bools[i]=1;
             clicked=false;
        }
        if(mouseX >= width/2-width/2.5f && mouseX <= width/2-width/2.5f + buttonSize && mouseY >= height/2+width/4 && mouseY <=height/2+width/4 + buttonSize && mousePressed){ //buy
           
            if(priceCheck(cost)){
              if(name=="assets/powerUps/grow.powerUp.png"){
                    powerup[0].count++;
                    bools[0]=1;//prevents mouse hold
                    clicked=false;
              }
              if(name=="assets/powerUps/shrink.powerUp.png" && (bools[1]==0)){
                    powerup[1].count++;
                    bools[1]=1;//prevents mouse hold
                    clicked=false;
              }
              if(name=="assets/powerUps/skip.powerUp.png" && (bools[2]==0)){
                   powerup[2].count++;
                   bools[2]=1;//prevents mouse hold
                   clicked=false;
              }
              if(name=="assets/powerUps/heal.powerUp.png" && (bools[3]==0)){
                   powerup[3].count++;
                   bools[3]=1;//prevents mouse hold
                   clicked=false;
              }
              player.setCurrency(player.getCurrency()-cost);
              cantAfford=0;
            }
        }

    }
    
    
     public void spellPurOrNot(int Boughtnum,String name,float width ,float height,float size){
      
       if(!bought[Boughtnum]){
    
               makebutton(width, height,name,size);
        } 
        else
            makebutton(width, height,Bought,size);
    }

     public void buttonLayout(){ // creates the layout
    
        textSize(width/15);
        fill(0);
        text(player.getCurrency()+" coins", new_width*1.2f, new_height-(height/heightRatio)*.6f); 
        textAlign(CENTER);
        
        String name="assets/items/spell.item.png";
        
        //powerups
        makebutton(new_width, new_height, "assets/powerUps/grow.powerUp.png", buttonSize);
        makebutton(new_width-(width/widthRatio), new_height, "assets/powerUps/shrink.powerUp.png", buttonSize);
        makebutton(new_width, new_height+(height/heightRatio), "assets/powerUps/skip.powerUp.png", buttonSize);
        makebutton(new_width-(width/widthRatio), new_height+(height/heightRatio), "assets/powerUps/heal.powerUp.png", buttonSize);
        
        //spells
        spellPurOrNot(0,name,new_width-(width/widthRatio),new_height+(height/5),buttonSize);
        spellPurOrNot(1,name,new_width,new_height+(height/5),buttonSize);
        spellPurOrNot(2,name,new_width+(width/widthRatio),new_height,buttonSize);
        spellPurOrNot(3,name,new_width+(width/widthRatio), new_height+(height/heightRatio),buttonSize);
        
        makebutton(new_width+(width/widthRatio), new_height+(height/5), "assets/items/shopkeeper.png", buttonSize);//chage when image is ready
      

    
        //done
        makebutton(new_width, height/1.58f, "assets/buttons/go.png", buttonSize);//chage when done button is made
    } 

     public void printshop(PowerUp powerup[]){//prints buysrceen in shop
        //shop
        if(bools[0]==0)
            buyScreen("assets/powerUps/grow.powerUp.png", powerup);
        if(bools[1]==0)
            buyScreen("assets/powerUps/shrink.powerUp.png", powerup);
        if(bools[2]==0)
            buyScreen("assets/powerUps/skip.powerUp.png", powerup);
        if(bools[3]==0)
            buyScreen("assets/powerUps/heal.powerUp.png", powerup);
        for(int i = 0; i < 4; i++)
            if(bools[i+4]==0 && randSpell[i]!=-1)
                buySpellScreen(randSpell[i]); 
                
        if(bools[8]==0)
          StatScreen();
    }

     public void mouseClicked(int boolnum,float new_width,float new_height,float buttonSize ){//for the items in the shop
        if(clicked==false){ 
            //power ups
            if(mouseX >= new_width && mouseX <= new_width + buttonSize && mouseY >= new_height && mouseY <= new_height + buttonSize && mousePressed)
                bools[boolnum]=0;     
        }

    }
    
    public void presses(){
      //powerup
      mouseClicked(0,new_width,new_height,buttonSize);
      mouseClicked(1,new_width-(width/widthRatio),new_height,buttonSize);
      mouseClicked(2,new_width,new_height+(height/heightRatio),buttonSize);
      mouseClicked(3,new_width-(width/widthRatio) ,new_height+(height/heightRatio),buttonSize);
      //spell
  
      if(bought[0]==false)
      mouseClicked(4,new_width-(width/widthRatio),new_height+(height/5),buttonSize);
      if(bought[1]==false)
      mouseClicked(5,new_width,new_height+(height/5),buttonSize);
      if(bought[2]==false)
      mouseClicked(6,new_width+(width/widthRatio),new_height,buttonSize);
      if(bought[3]==false)
      mouseClicked(7,new_width+(width/widthRatio),new_height+(height/heightRatio),buttonSize);
      
      
      mouseClicked(8,new_width+(width/widthRatio),new_height+(height/5),buttonSize);
      
      
    }

    public int exitShop(){ //if done is pressed you return back to battle screen
        if(mouseX >= new_width && mouseX <= new_width + buttonSize && mouseY >= height/1.58f && mouseY <= height/1.58f + buttonSize && mousePressed){
            for(int i=0;i<4;i++){
             spellbook.getSpellIndexed(randSpell[i]).available=bought[i]; 
             bought[i]=false;
            } 
            RandSpell=false;
            player.effect('h');
            return 1;
        }
        return 0; 
    }
     
    public int show(PowerUp powerup[]){
        shop = buttons.get("assets/Shop.png");
        if(RandSpell==false)
        RandomSpells();
        stroke(0);
        background(theme.getBackground());
        image(shop, 0, 0, wid, hei);
        buttonLayout();
        presses();
        printshop(powerup);
        //shoopKeeper();
        return exitShop();   
    }
}
class Spell{
    String name;
    int damage;
    char type;
    String flavor;
    boolean available;
    State state;

    Spell(String encoded){
        String parts[] = encoded.split(";");
        name = parts[0];
        damage = parseInt(parts[1]);
        type = parts[2].charAt(0);
        flavor = parts[3];
        available = parts[4].equals("1") || parts[4].toLowerCase().equals("true");
        state = new State(Long.parseLong(parts[5]));
    }

    public void show(float x, float y, float w, float h, Theme theme){
        state.show(x, y, w/2, theme.getOn(), theme.getOff());
        textAlign(CENTER, CENTER);
        float tSize = w/2/pow((""+damage).length(), .7f);
        textSize(tSize);
        fill(typeToTint());
        rect(x+w/2,y,w/2,w/2);
        fill(0);
        text(""+damage, x+3*w/4, y+w/5.6f);
        textAlign(CENTER, BOTTOM);
        fill(theme.getOff());
        textSize(w/10);
        text(name, x+w/2, y+3*w/4);
        textAlign(LEFT, TOP);
        textSize(w/15);
        text(flavor, x, y+3*w/4, w, y+5*h/8);
    }

    public String getStateEncoded(){
        return state.toString();
    }

    public long getEncoded(){
        return state.getEncoded();
    }

    private int typeToTint(){
        switch(type){
            case 'a':
                return color(255,255,150);
            case 'e':
                return color(50,150,50);
            case 'f':
                return color(255,100,100);
            case 'w':
                return color(150,150,255);
        }
        return color(200);
    }
}
  // Import the File class
  // Import this class to handle errors
 // Import the Scanner class to read text files


class Spellbook{
    private Hashtable <Long, Spell> spells = new Hashtable<Long, Spell>();
    private long spellsLookup[];
    private PImage background;
    private float x, y, w, h;

    public boolean visible = false, toggleable = false;
    public int visibleIndex = 0;
    int spellCount = 0;

    Spellbook(String spellFile, String bgFile){
        loadSpells(spellFile);
        background = loadImage("assets/"+ bgFile + ".spellbook.png");
    }

    private void loadSpells(String filename){
        try {
            String[] lines = loadStrings(filename);
            spellsLookup = new long[lines.length];
            for(int i=0; i<lines.length;i++) {
                if(lines[i].split(";").length>5){
                    Spell temp = new Spell(lines[i]);
                    spells.put(temp.getEncoded(), temp);
                    spellsLookup[spellCount++] = temp.getEncoded();
                }
            }
        } catch (NullPointerException e) {
            println("Spells file not found!"); // Display to screen
            e.printStackTrace();
        }
    }

    public void click(int mX, int mY, BattleScreen screen){
        int attempts = 0;
        do {
            if(pow(x+3*w/16-mX,2)+pow(y+7*h/8-mY,2)<pow(screen.margin,2)){
                visibleIndex = ((visibleIndex - 1)+spellCount)%spellCount;
            } else if(pow(x+13*w/16-mX,2)+pow(y+7*h/8-mY,2)<pow(screen.margin,2)){
                visibleIndex = (visibleIndex + 1)%spellCount;
            }
        } while(!getSpellIndexed(visibleIndex).available && attempts++<spellCount-1);
    }

    public void show(float deployment, float w_, float h_, BattleScreen screen, Theme theme){
        w = w_;
        h = h_;
        if(toggleable){
            if(visible){
                x = map(constrain(deployment, -1, 0), -1, 0, width-screen.margin/2, width/2-w/2);
            } else {
                x = map(constrain(deployment,  0, 1),  0, 1, width-screen.margin/2, width/2-w/2);
            }
            if(deployment>1){
                visible=true;
            } else if(deployment<-1){
                visible=false;
            }
        } else if(visible){
            x = width/2-w/2;
        } else {
            x = width-screen.margin/2;
        }
        y = height/2-h/2;
        tint(theme.getOn());
        image(background, x, y, w, h);
        tint(255);
        fill(theme.getOff());
        triangle(x+w/8,y+7*h/8, x+w/4,y+13*h/16, x+w/4,y+15*h/16);
        triangle(x+7*w/8,y+7*h/8, x+3*w/4,y+13*h/16, x+3*w/4,y+15*h/16);
        if(x+screen.margin/2<width)spells.get(spellsLookup[visibleIndex]).show(x+screen.margin/2,y+screen.margin/2,w-screen.margin,h-screen.margin, theme);
    }

    public Spell getSpell(long encodedTopState){
        return spells.get(encodedTopState);
    }

    public Spell getSpellIndexed(int spellNum){
        return spells.get(spellsLookup[spellNum]);    
    }

    public int getSpellCount(){
        return spellCount;
    }

    public int someSpellsUnavailable(){
        int count = 0;
        for(int i=0;i<getSpellCount();i++){
            if(!getSpellIndexed(i).available)count++;
        }
        return count;
    }

    public String getAvailableSpells(){
        String out = "";
        for(int i = 0; i < spellCount; i++){
            Spell temp = getSpellIndexed(i);
            if(temp.available)out+=temp.getStateEncoded()+",";
        }
        out = out.substring(0,max(out.length()-1,0));
        return out;
    }

    public void updateAvailableSpells(String encodedList){
        String stateCodes[] = encodedList.split(",");
        for(int i=0;i<spellCount;i++){
            getSpellIndexed(i).available = false;
        }
        for(String s : stateCodes){
            long temp = new State().StringToLong(s);
            if(spells.containsKey(temp))
                spells.get(temp).available = true;
        }
    }
}




//made by @ardentsuccubus @ardenttcg.com/// 

      


class SplashScreen extends Screen
{
  
  // done is the condition to switch screens and we incre by one for new screen
  boolean done = true; // This is wrong for testing
  //wanted to add more images
  String Filename[] = {"assets/backgrounds/splashScreen.png",
    "assets/backgrounds/SymbologyTitle.png"};

  String loadedString = ""; // Put the string you get from firebase in here before you return true.

  HashMap<String, PImage> Background = new HashMap<String, PImage>(Filename.length*2);
  //constructer
  public SplashScreen(int width,int height)
  {
    super(width,height);
    for(String imageFilename : Filename)
    {
      addImage(imageFilename);
    }
    // Start the google and firebase queries






  }
  //adds image
  private void addImage(String name){
      Background.put(name, loadImage(name));
  }
    
    
    
     
  //loads image to show
  public boolean show(){
    image(Background.get("assets/backgrounds/splashScreen.png"),    0,  0, wid,     hei  );
    image(Background.get("assets/backgrounds/SymbologyTitle.png"), 50, 50, wid/1.3f, wid/10);
    return done;
  }
    
    //
    
    /*
      this section is for the google play login 
      to call google play then auth the google play for firebase to get the userid from
      the database created
      
      it goes from the email -> user -> string stored to find the data
      
      GoogleSignnInOptions gso;
      GoogleSignInClient gsc;
      
      
      gso = new GoogleSignInoption.Builder (GoogleSignInOptions.DEFAULT_sign_in).requestEmail.().Build)'
      
      gsc = GoogleSignIn.getClient();
      
      
      SignIn();
      
      
      void SignIn()
      {
        Intent  signInIntent = gsc.getSignInIntent();
        startActivityForResult(signInIntent,1000);
      }
      
      @Override
      Protected void onActivityResults (int reqquestCode, int Resultcode, intent data){
        super. o n activity result(requestcode,resultCode,data);
        
        
        if(requestCode == 10000){
          //Task google sing in stuff
          
          try {
            
            //navigate to secoundActivity
          }
          catch(ApiException e)
          {
            //error text
          }
          
        
    
    */
  

}
class State{
    boolean[][] subState;
    boolean[][] topState;
    long encodedSubState;
    long encodedTopState;
    int size;
    
    // Constructors
    State(boolean[][] state){
        encodedSubState = convert(state);
        size = state.length;
        subState = state;
        calc();
    }
    State(long state){
        size = (int)(state%8);
        subState = new boolean[size][size];
        topState = new boolean[size][size];
        encodedSubState = state;
        subState = convert(state);
        calc();
    }
    State(String state){
        this(new State().StringToLong(state));
    }
    State(int size_){
        size = size_;
        subState = new boolean[size][size];
        topState = new boolean[size][size];
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                subState[i][j] = false;
            }
        }
        calc();
        encodedSubState = convert(subState);
        encodedTopState = convert(topState);
    }
    State(boolean irrelevant){ // This is weird, make sure it works
        this((long)random(1<<3,1<<54) + 3); 
    }
    State(){}

    // Cell Math
    public void click(int x, int y){
        subState[x][y] = !subState[x][y];
        calc();
    }
    public void calc(){
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                sum(i, j);
            }
        }
        encodedTopState = convert(topState);
    }
    private void sum(int x, int y){
        boolean out = !subState[x][y];
        if(x>0&&subState[x-1][y])out=!out;
        if(y>0&&subState[x][y-1])out=!out;
        if(x<size-1&&subState[x+1][y])out=!out;
        if(y<size-1&&subState[x][y+1])out=!out;
        topState[x][y] = out;
    }
    public void scramble(){
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                subState[i][j] = random(0,1) < 0.5f;
            }
        }
        calc();
    }

    // Resizing
    public int getSize(){
        return size;
    }
    private boolean[][] resize(boolean[][] board, int newSize){
        if(board.length == newSize)return board;
        boolean[][] out = new boolean[newSize][newSize];
        int offset = abs(newSize-board.length)/2 + (newSize + ((0<(board.length - newSize))?1:0))%2;
        boolean bigger = newSize > board.length;
        for(int i = 0; i < min(newSize, board.length); i++){
            for(int j = 0; j < min(newSize, board.length); j++){
                if(bigger){
                    out[i+offset][j+offset] = board[i][j];
                } else {
                    out[i][j] = board[i+offset][j+offset];
                }
            }
        }
        return out;
    }
    public boolean resize(int newSize){
        if(newSize<3||newSize>7)return false;
        subState = resize(subState, newSize);
        topState = resize(topState, newSize);
        size = newSize;
        calc();
        return true;
    }

    // Encoding
    public long getEncoded(){
        calc();
        return encodedTopState;
    }
    public long convert(boolean[][] state){
        long out = 0;
        for(int i = 0; i < size*size; i++){
            out<<=1;
            out+=(state[i%size][i/size])?1:0;
        }
        out<<=3;
        out+=size;
        return out;
    }
    public boolean[][] convert(long in){
        size = (int)(in%8);
        boolean out[][] = new boolean[size][size];
        in>>=3;
        for(int i = size*size-1; i >= 0; i--){
        out[i%size][i/size] = in%2==1;
        in>>=1;
        }
        return out;
    }
    public String toString(){
        long original = encodedSubState;
        String out = "";
        int bitBit = 1<<5;

        while(original > 0){
            int temp = 0;
            for(int i = 0; i < 6; i++){
                temp >>= 1;
                temp += bitBit * (original%2);
                original >>= 1;
            }
            out = intToChar(temp)+out;
        }
        return out;
    }
    public long StringToLong(String state){
        long out = 0;
        for(char c : state.toCharArray()) {
            out <<= 6;
            out += charToInt(c);
        }
        return out;
    }

    // Show
    public void show(float x, float y, float gWidth, int on, int off){
        if(size<1)return;
        strokeWeight(1);
        stroke(0);
        fill(on);
        for(int i = 0; i < size; i++)
          for(int j = 0; j < size; j++)
            if(topState[i][j])
              rect(x+i*gWidth/size, y+j*gWidth/size, gWidth/size, gWidth/size);
        fill(off);
        for(int i = 0; i < size; i++)
          for(int j = 0; j < size; j++)
            if(!topState[i][j])
              rect(x+i*gWidth/size, y+j*gWidth/size, gWidth/size, gWidth/size);
    }
    public void show(float x, float y, float gWidth, int on, int off, boolean debug){
        show(x, y, gWidth, on, off);
        if(!debug)return;
        fill(color(255,0,0));
        for(int i = 0; i < size; i++)
          for(int j = 0; j < size; j++)
            if(subState[i][j])
              ellipse(x+(i+.5f)*gWidth/size, y+(j+.5f)*gWidth/size, gWidth/size/2, gWidth/size/2);
    }

    private char intToChar(int x){
        if(x==constrain(x, 0, 9)){
            return (char)('0'+x);
        }
        if(x==constrain(x, 10, 35)){
            return (char)('a'+x-10);
        }
        if(x==constrain(x, 36, 64)){
            return (char)('A'+x-36);
        }
        return '$';
    }
    private int charToInt(char x_){
        int x = (int)x_;
        if(x==constrain(x, (int)'0', (int)'9')){
            return x-'0';
        }
        if(x==constrain(x, (int)'a', (int)'z')){
            return x-'a'+10;
        }
        if(x==constrain(x, (int)'A', (int)'Z')){
            return x-'A'+36;
        }
        return 0;
    }

 }
class Theme{
    protected int on;
    protected int off;
    protected int background;
    protected PImage backgroundImage;
    public PImage enemyHealthBar = loadImage("assets/monster.hpbar.png");
    public PImage playerHealthBar = loadImage("assets/player.hpbar.png");

    Theme(int on_, int off_, int background_, String backgroundImageFilename, int wid, int hei){
        on = on_;
        off = off_;
        background = background_;
        backgroundImage = loadImage("assets/backgrounds/"+backgroundImageFilename+".background.png");
        backgroundImage.resize(wid,hei);
    }

    public int getOn(){
        return on;
    }
    public int getOff(){
        return off;
    }
    public int getBackground(){
        return background;
    }
    public PImage getBackgroundImage(){
        return backgroundImage;
    }

    public void update(){}
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Symbology" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
