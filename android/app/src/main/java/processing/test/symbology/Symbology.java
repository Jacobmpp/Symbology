package processing.test.symbology;

/* autogenerated by Processing revision 1286 on 2022-09-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Symbology extends PApplet {

boolean debug = true;
int screen = 2;
BattleScreen battleScreen;
Player player;
Theme currentTheme;

 public void setup(){
    /* size commented out by preprocessor */;
    ellipseMode(CENTER);
    rectMode(CORNER);
    float margin = min(width, 3*height/4)/6;
    float gameWidth = min(width, 3*height/4)-margin*2;
    textSize(margin/3);
    textAlign(CENTER);
    battleScreen = new BattleScreen(margin, gameWidth, new Player(1000, 1));
}

 public void mousePressed(){
    if(screen==2){
        battleScreen.mousePressed(mouseX, mouseY);
    }

}

 public void keyPressed(){
    if(key=='d'){
        debug=!debug;
    }
}

 public void draw(){
    if(screen==2){
        battleScreen.show(debug);
    }
}
class AnimatedTheme extends Theme {
    int speed;

    public AnimatedTheme(int on_, int off_, int speed_){
        super(on_, off_);
        speed=speed_;
    }

    @Override
    public int getOn(){
        colorMode(HSB,255);
        on = color((hue(on)+speed)%256, saturation(on), brightness(on));
        colorMode(RGB,255);
        return on;
    }
}
class BattleScreen extends Screen{
    Player player;
    Enemy enemy;
    GameBoard grid;
    PowerUp powerUps[];

    public BattleScreen(float margin_, float gameWidth_, Player player_){
        super(margin_, gameWidth_);
        player = player_;
        enemy = new Enemy(player.getLevel());
        GameBoard grid = new GameBoard((int)gameWidth_);
    }

    public void mousePressed(int mx, int my){
        int size = grid.getState().getSize();
        int x = floor((mx-margin)/(gameWidth/size));
        int y = floor((my-margin)/(gameWidth/size));
        if(!(x>=size||x<0 || y>=size||y<0)){
            grid.getState().click(x,y);
        }
    }

    public void show(boolean debug){
        
    }
}
class Enemy{
    private String[] fileNames = new String[] {"green"};
    private int maxHp;
    private int hp;
    private int damage;
    private char resistance;
    private PImage sprite;

    Enemy(int maxHp_, int damage_, PImage sprite_){
        maxHp = maxHp_;
        hp = maxHp_;
        damage = damage_;
        sprite = sprite_;
    }
    Enemy(int maxHp_, int damage_, String spriteFilename){
        maxHp=maxHp_;
        hp=maxHp_;
        damage=damage_;
        sprite=loadImage(spriteFilename+".monster.png");;
    }
    Enemy(int level){
      //TODO: make "random" enemy based on level as seed
    }

    public boolean takeDamage(int amount){
        hp-=amount;
        return hp>0;
    }

    public int getHp(){
        return hp;
    }
    public int getMaxHp(){
        return maxHp;
    }

    public void show(float x, float y, int w, int h){
        if(sprite.width!=w||sprite.height!=h) sprite.resize(w,h);
        image(sprite, x, y);
    }
}
class GameBoard{
    private State state;
    private int lastSize = 0;
    private PImage board, original; //(Processing required)

    // Constructor
    GameBoard(State state_, int gWidth){
        state = state_;
        loadImages("assets/brick", gWidth);
    }
    GameBoard(int gWidth){
      this(new State(3), gWidth);
    }

    // State Functions
    public void click(int x, int y){
        state.click(x, y);
    }
    public int getSize(){
        return state.getSize();
    }
    public State getState(){
        return state;
    }
    public boolean resize(int newSize){
      return state.resize(newSize);
    }

    // Load Images (Processing required)
    private void loadImages(String filename, int gWidth){
        original = loadImage(filename+".board.png");
        board = original.get(((7-state.getSize())/2)*16,((7-state.getSize())/2)*16,16*state.getSize(),16*state.getSize());
        board.resize(gWidth,gWidth);
    }

    // Show (Processing required)
    public void show(float x, float y, int gWidth, int on, int off, int stroke, float strokeWeight){
        int size = state.getSize();
        if(size<1)return;
        if(size!=lastSize){
            board = original.get(((7-state.getSize())/2)*16,((7-state.getSize())/2)*16,16*state.getSize(),16*state.getSize());
            board.resize(gWidth,gWidth);
            lastSize = size;
        }
        state.show(x, y, gWidth, on, off, stroke, strokeWeight);
        image(board, x, y);
    }
}
class Player{

    private int hp;
    private int level;
    private Spellbook spellbook;

    public Player(int hp_, int level_){
        hp = hp_;
        level = level_;
        spellbook = new Spellbook("spells.dat");
    }

    public void effect(char stat, int mag){
        switch(stat) {
            case 'h':
                hp+=mag;
                break;
        }
    }
    
    public int getLevel(){
      return level;
    }
}
class PowerUp{
    String name;
    int count;
    int resize;
    char stat;
    int magnitude;
    PImage favicon;

    public PowerUp(String name_, int count_, int resize_){
      name = name_;
      count = count_;
      resize = resize_;
    }
    public PowerUp(String name_, int count_, char stat_, int magnitude_){
      name = name_;
      count = count_;
      stat = stat_;
      magnitude = magnitude_;
    }

    public void show(float x, float y, int w, int h) {
        favicon.resize(w, h);
        image(favicon, x, y);
    }

    public boolean use(GameBoard gb){
        if(count > 0){
            if(resize!=0){
                gb.resize(gb.getSize()+resize);
            }
            count--;
            return true;
        }
        return false;
    }

    public boolean use(Player p){
        if(count > 0){
            p.effect(stat, magnitude);
            count--;
            return true;
        }
        return false;
    }
}
abstract class Screen {
    float margin;
    float gameWidth;
    
    public Screen(float margin_, float gameWidth_){
      margin = margin_;
      gameWidth = gameWidth_;
    }
}
class Spell{
    int damage;
    char type;
    String flavor;
    boolean discoverable;
    State state;
    
    Spell(String encoded){
        String parts[] = encoded.split(",");
        damage = parseInt(parts[0]);
        type = parts[1].charAt(0);
        flavor = parts[2];
        discoverable = parts[3].equals("1") || parts[3].toLowerCase().equals("true");
        state = new State(Long.parseLong(parts[4]));
    }

    public void show(float x, float y, float w, float h){
        //TODO
    }
}
  // Import the File class
  // Import this class to handle errors
 // Import the Scanner class to read text files

class Spellbook{
    Spell spells[];
    boolean avalable[];
    int index = 0;
    
    Spellbook(String filename){
        loadSpells(filename);
    }
    
    private void loadSpells(String filename){
        try {
            String[] lines = loadStrings(filename);
            spells = new Spell[lines.length];
            for(int i=0; i<lines.length;i++) {
                spells[i-1]=new Spell(lines[i]);
            }
        } catch (NullPointerException e) {
            System.out.println("Spells file not found!"); // Display to screen
            e.printStackTrace();
        }
    }
    
    public void show(int index, float x, float y, float w, float h){
        spells[index].show(x,y,w,h);
    }
}
class State{
    boolean[][] subState;
    boolean[][] topState;
    long encodedTopState;
    int size;
    
    // Constructors
    State(boolean[][] state){
        size = state.length;
        subState = state;
        calc();
    }
    State(long state){
        convert(state);
    }
    State(int size_){
        size = size_;
        subState = new boolean[size][size];
        topState = new boolean[size][size];
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                subState[i][j] = false;
            }
        }
        calc();
    }
    State(){ // This is weird, make sure it works
        this((long)random(1<<3,1<<54) + 3); 
    }

    // Cell Math
    public void click(int x, int y){
        subState[x][y] = !subState[x][y];
        calc();
    }
    public void calc(){
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                sum(i, j);
            }
        }
        encodedTopState = convert(topState);
    }
    private void sum(int x, int y){
        boolean out = true;
        if(x>0&&subState[x-1][y])out=!out;
        if(y>0&&subState[x][y-1])out=!out;
        if(x<size-1&&subState[x+1][y])out=!out;
        if(y<size-1&&subState[x][y+1])out=!out;
        topState[x][y] = out;
    }

    // Resizing
    public int getSize(){
        return size;
    }
    private boolean[][] resize(boolean[][] board, int newSize){
        if(board.length == newSize)return board;
        boolean[][] out = new boolean[newSize][newSize];
        int offset = abs(newSize-board.length)/2 + (newSize + ((0<(board.length - newSize))?1:0))%2;
        boolean bigger = newSize > board.length;
        for(int i = 0; i < min(newSize, board.length); i++){
            for(int j = 0; j < min(newSize, board.length); j++){
                if(bigger){
                    out[i+offset][j+offset] = board[i][j];
                } else {
                    out[i][j] = board[i+offset][j+offset];
                }
            }
        }
        return out;
    }
    public boolean resize(int newSize){
        if(newSize<3||newSize>7)return false;
        subState = resize(subState, newSize);
        topState = resize(topState, newSize);
        size = newSize;
        return true;
    }

    // Encoding
    public long getEncoded(){
        return encodedTopState;
    }
    public long convert(boolean[][] state){
        long out = 0;
        for(int i = 0; i < size*size; i++){
            out<<=1;
            out+=(state[i%size][i/size])?1:0;
        }
        out<<=3;
        out+=size;
        return out;
    }
    public boolean[][] convert(long in){
        int s = (int)in%8;
        boolean out[][] = new boolean[s][s];
        in>>=3;
        for(int i = s*s-1; i >= 0; i--){
        out[i%s][i/s] = in%2==1;
        in>>=1;
        }
        return out;
    }

    // Show (Processing required)
    public void show(float x, float y, float gWidth, int on, int off, int stroke, float strokeWeight){
        if(size<1)return;
        strokeWeight(strokeWeight);
        stroke(stroke);
        fill(on);
        for(int i = 0; i < size; i++)
          for(int j = 0; j < size; j++)
            if(topState[i][j])
              rect(x+i*gWidth/size, y+j*gWidth/size, gWidth/size, gWidth/size);
        fill(off);
        for(int i = 0; i < size; i++)
          for(int j = 0; j < size; j++)
            if(!topState[i][j])
              rect(x+i*gWidth/size, y+j*gWidth/size, gWidth/size, gWidth/size);
    }
    public void show(float x, float y, float gWidth, int on, int off, int stroke, float strokeWeight, boolean debug){
        show(x, y, gWidth, on, off, stroke, strokeWeight);
        if(!debug)
        fill(color(255,0,0));
        for(int i = 0; i < size; i++)
          for(int j = 0; j < size; j++)
            if(!topState[i][j])
              ellipse(x+(i+.5f)*gWidth/size, y+(j+.5f)*gWidth/size, gWidth/size/2, gWidth/size/2);
    }
 }
class Theme{
    protected int on;
    protected int off;

    Theme(int on_, int off_){
        on = on_;
        off = off_;
    }

    public int getOn(){
        return on;
    }
    public int getOff(){
        return off;
    }
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Symbology" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
